package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.68

import (
	"context"
	"fmt"
	"backend/db"
	"backend/graph/model"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo/options"
)

func (r *queryResolver) SearchStates(ctx context.Context, query string) ([]*model.State, error) {
	fmt.Println("searchStates 被调用，查询: ", query)

	var states []*model.State
	collection := db.MongoClient.Database("us_states").Collection("states")

	// 处理输入为空的情况
	if query == "" {
		fmt.Println("⚠️ 查询为空，返回空结果")
		return []*model.State{}, nil
	}

	// 构造查询条件（匹配以 query 开头的州，不区分大小写）
	filter := bson.M{"name": bson.M{"$regex": "^" + query, "$options": "i"}}

	// 按名称升序排序
	opts := options.Find().SetSort(bson.D{{"name", 1}})

	cursor, err := collection.Find(ctx, filter, opts)
	if err != nil {
		fmt.Println("❌ 查询 MongoDB 失败:", err)
		return nil, err
	}
	defer cursor.Close(ctx)

	for cursor.Next(ctx) {
		var state model.State
		if err := cursor.Decode(&state); err != nil {
			fmt.Println("❌ 解码 MongoDB 结果失败:", err)
			return nil, err
		}
		states = append(states, &state)
	}

	fmt.Printf("✅ 查询成功，共返回 %d 条数据\n", len(states))
	return states, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
